// Generated by CoffeeScript 1.12.7
(function() {
  var algorithms, filterCoefficients, k, v,
    hasProp = {}.hasOwnProperty;

  if (this.chromaprint == null) {
    this.chromaprint = {};
  }

  filterCoefficients = [0.25, 0.75, 1, 0.75, 0.25];

  algorithms = {
    1: {
      filterCoefficients: filterCoefficients,
      interpolate: false,
      classifierCoefficients: [
        {
          f: [0, 0, 3, 15],
          q: [2.10543, 2.45354, 2.69414]
        }, {
          f: [1, 0, 4, 14],
          q: [-0.345922, 0.0463746, 0.446251]
        }, {
          f: [1, 4, 4, 11],
          q: [-0.392132, 0.0291077, 0.443391]
        }, {
          f: [3, 0, 4, 14],
          q: [-0.192851, 0.00583535, 0.204053]
        }, {
          f: [2, 8, 2, 4],
          q: [-0.0771619, -0.00991999, 0.0575406]
        }, {
          f: [5, 6, 2, 15],
          q: [-0.710437, -0.518954, -0.330402]
        }, {
          f: [1, 9, 2, 16],
          q: [-0.353724, -0.0189719, 0.289768]
        }, {
          f: [3, 4, 2, 10],
          q: [-0.128418, -0.0285697, 0.0591791]
        }, {
          f: [3, 9, 2, 16],
          q: [-0.139052, -0.0228468, 0.0879723]
        }, {
          f: [2, 1, 3, 6],
          q: [-0.133562, 0.00669205, 0.155012]
        }, {
          f: [3, 3, 6, 2],
          q: [-0.0267, 0.00804829, 0.0459773]
        }, {
          f: [2, 8, 1, 10],
          q: [-0.0972417, 0.0152227, 0.129003]
        }, {
          f: [3, 4, 4, 14],
          q: [-0.141434, 0.00374515, 0.149935]
        }, {
          f: [5, 4, 2, 15],
          q: [-0.64035, -0.466999, -0.285493]
        }, {
          f: [5, 9, 2, 3],
          q: [-0.322792, -0.254258, -0.174278]
        }, {
          f: [2, 1, 8, 4],
          q: [-0.0741375, -0.00590933, 0.0600357]
        }
      ]
    },
    2: {
      filterCoefficients: filterCoefficients,
      interpolate: false,
      classifierCoefficients: [
        {
          f: [0, 4, 3, 15],
          q: [1.98215, 2.35817, 2.63523]
        }, {
          f: [4, 4, 6, 15],
          q: [-1.03809, -0.651211, -0.282167]
        }, {
          f: [1, 0, 4, 16],
          q: [-0.298702, 0.119262, 0.558497]
        }, {
          f: [3, 8, 2, 12],
          q: [-0.105439, 0.0153946, 0.135898]
        }, {
          f: [3, 4, 4, 8],
          q: [-0.142891, 0.0258736, 0.200632]
        }, {
          f: [4, 0, 3, 5],
          q: [-0.826319, -0.590612, -0.368214]
        }, {
          f: [1, 2, 2, 9],
          q: [-0.557409, -0.233035, 0.0534525]
        }, {
          f: [2, 7, 3, 4],
          q: [-0.0646826, 0.00620476, 0.0784847]
        }, {
          f: [2, 6, 2, 16],
          q: [-0.192387, -0.029699, 0.215855]
        }, {
          f: [2, 1, 3, 2],
          q: [-0.0397818, -0.00568076, 0.0292026]
        }, {
          f: [5, 10, 1, 15],
          q: [-0.53823, -0.369934, -0.190235]
        }, {
          f: [3, 6, 2, 10],
          q: [-0.124877, 0.0296483, 0.139239]
        }, {
          f: [2, 1, 1, 14],
          q: [-0.101475, 0.0225617, 0.231971]
        }, {
          f: [3, 5, 6, 4],
          q: [-0.0799915, -0.00729616, 0.063262]
        }, {
          f: [1, 9, 2, 12],
          q: [-0.272556, 0.019424, 0.302559]
        }, {
          f: [3, 4, 2, 14],
          q: [-0.164292, -0.0321188, 0.0846339]
        }
      ]
    },
    3: {
      filterCoefficients: filterCoefficients,
      interpolate: false,
      classifierCoefficients: [
        {
          f: [0, 4, 3, 15],
          q: [1.98215, 2.35817, 2.63523]
        }, {
          f: [4, 4, 6, 15],
          q: [-1.03809, -0.651211, -0.282167]
        }, {
          f: [1, 0, 4, 16],
          q: [-0.298702, 0.119262, 0.558497]
        }, {
          f: [3, 8, 2, 12],
          q: [-0.105439, 0.0153946, 0.135898]
        }, {
          f: [3, 4, 4, 8],
          q: [-0.142891, 0.0258736, 0.200632]
        }, {
          f: [4, 0, 3, 5],
          q: [-0.826319, -0.590612, -0.368214]
        }, {
          f: [1, 2, 2, 9],
          q: [-0.557409, -0.233035, 0.0534525]
        }, {
          f: [2, 7, 3, 4],
          q: [-0.0646826, 0.00620476, 0.0784847]
        }, {
          f: [2, 6, 2, 16],
          q: [-0.192387, -0.029699, 0.215855]
        }, {
          f: [2, 1, 3, 2],
          q: [-0.0397818, -0.00568076, 0.0292026]
        }, {
          f: [5, 10, 1, 15],
          q: [-0.53823, -0.369934, -0.190235]
        }, {
          f: [3, 6, 2, 10],
          q: [-0.124877, 0.0296483, 0.139239]
        }, {
          f: [2, 1, 1, 14],
          q: [-0.101475, 0.0225617, 0.231971]
        }, {
          f: [3, 5, 6, 4],
          q: [-0.0799915, -0.00729616, 0.063262]
        }, {
          f: [1, 9, 2, 12],
          q: [-0.272556, 0.019424, 0.302559]
        }, {
          f: [3, 4, 2, 14],
          q: [-0.164292, -0.0321188, 0.0846339]
        }
      ]
    },
    4: {
      removeSilence: true,
      silenceThreshold: 50
    }
  };

  for (k in algorithms) {
    if (!hasProp.call(algorithms, k)) continue;
    v = algorithms[k];
    algorithms[Number(k)] = v;
  }

  algorithms["default"] = algorithms[2];

  this.chromaprint.ALGORITHMS = algorithms;

}).call(this);
// Generated by CoffeeScript 1.12.7
(function() {
  var GRAYCODE, area, calculator, classifier, filter, integral, measure, quantizer,
    slice = [].slice;

  if (this.chromaprint == null) {
    this.chromaprint = {};
  }

  GRAYCODE = [0, 1, 3, 2];

  this.chromaprint.GRAYCODE = GRAYCODE;

  integral = function(image) {
    var result;
    result = [];
    image.forEach(function(row, i) {
      if (result[i] == null) {
        result[i] = [];
      }
      return row.forEach(function(n, j) {
        var ref, ref1, ref2, ref3, ref4, ref5;
        return result[i][j] = n + ((ref = (ref1 = result[i]) != null ? ref1[j - 1] : void 0) != null ? ref : 0) + ((ref2 = (ref3 = result[i - 1]) != null ? ref3[j] : void 0) != null ? ref2 : 0) - ((ref4 = (ref5 = result[i - 1]) != null ? ref5[j - 1] : void 0) != null ? ref4 : 0);
      });
    });
    return result;
  };

  area = function(image, x1, y1, x2, y2) {
    var ref, ref1, result;
    if (x1 == null) {
      x1 = 0;
    }
    if (y1 == null) {
      y1 = 0;
    }
    if (x2 == null) {
      x2 = image.length;
    }
    if (y2 == null) {
      y2 = (ref = image[x2]) != null ? ref.length : void 0;
    }
    result = (ref1 = image[x2]) != null ? ref1[y2] : void 0;
    if (x2 < x1 || y2 < y1) {
      return 0;
    }
    if (x1 > 0) {
      result -= image[x1 - 1][y2];
      if (y1 > 0) {
        result += image[x1 - 1][y1 - 1];
      }
    }
    if (y1 > 0) {
      result -= image[x2][y1 - 1];
    }
    return result;
  };

  measure = function(image) {
    var ref;
    return {
      h: image.length,
      w: (ref = image[0].length) != null ? ref : 0
    };
  };

  this.chromaprint.Image = {
    integral: integral,
    area: area,
    measure: measure
  };

  filter = function(type, y, w, h, cmp) {
    var f;
    if (cmp == null) {
      cmp = filter.compare.subtractLog;
    }
    f = function(img, x) {
      return filter[type](img, x, y, w, h, cmp);
    };
    f.w = w;
    f.h = h;
    f.y = y;
    return f;
  };

  filter[0] = function(img, x, y, w, h, cmp) {
    var a, b;
    a = area(img, x, y, x + w - 1, y + h - 1);
    b = 0;
    return cmp(a, b);
  };

  filter[1] = function(img, x, y, w, h, cmp) {
    var a, b, h2;
    h2 = h / 2;
    a = area(img, x, y + h2, x + w - 1, y + h - 1);
    b = area(img, x, y, x + w - 1, y + h2 - 1);
    return cmp(a, b);
  };

  filter[2] = function(img, x, y, w, h, cmp) {
    var a, b, w2;
    w2 = w / 2;
    a = area(img, x + w2, y, x + w - 1, y + h - 1);
    b = area(img, x, y, x + w2 - 1, y + y - 1);
    return cmp(a, b);
  };

  filter[3] = function(img, x, y, w, h, cmp) {
    var a, b, h2, ref, w2;
    ref = [w / 2, h / 2], w2 = ref[0], h2 = ref[1];
    a = area(img, x, y + h2, x + w2 - 1, y + h - 1) + area(img, x + w2, y, x + w - 1, y + h2 - 1);
    b = area(img, x, y, x + w2 - 1, y + h2 - 1) + area(img, x + w2, y + h2, x + w - 1, y + h - 1);
    return cmp(a, b);
  };

  filter[4] = function(img, x, y, w, h, cmp) {
    var a, b, h3;
    h3 = h / 3;
    a = area(img, x, y + h3, x + w - 1, y + 2 * h3 - 1);
    b = area(img, x, y, x + w - 1, y + h3 - 1) + area(img, x, y + 2 * h3, x + w - 1, y + h - 1);
    return cmp(a, b);
  };

  filter[5] = function(img, x, y, w, h, cmp) {
    var a, b, w3;
    w3 = w / 3;
    a = area(img, x + w3, y, x + 2 * w3 - 1, y + h - 1);
    b = area(img, x, y, x + w3 - 1, y + h - 1) + area(img, x + 2 * w3, y, x + w - 1, y + h(-1));
    return cmp(a, b);
  };

  filter.compare = {
    subtract: function(a, b) {
      return a - b;
    },
    subtractLog: function(a, b) {
      return Math.log(1 + a) - Math.log(1 + b);
    }
  };

  this.chromaprint.filter = filter;

  quantizer = function(t0, t1, t2) {
    return function(value) {
      if (value < t1) {
        if (value < t0) {
          return 0;
        }
        return 1;
      }
      if (value < t2) {
        return 2;
      }
      return 3;
    };
  };

  this.chromaprint.quantizer = quantizer;

  classifier = function(coefficients) {
    var f, fn, q;
    f = filter.apply(null, coefficients.f);
    q = quantizer.apply(null, coefficients.q);
    fn = function(image, offset) {
      return q(f(image, offset));
    };
    fn.filterWidth = f.w;
    return fn;
  };

  this.chromaprint.classifier = classifier;

  calculator = function() {
    var classifiers, coefficients, max, subfingerprint;
    coefficients = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    classifiers = coefficients.map(function(cc) {
      return classifier(cc);
    });
    max = classifiers.reduce((function(w, c) {
      return Math.max(w, c.filterWidth);
    }), 0);
    subfingerprint = function(image, offset) {
      var classify;
      classify = function(b, classifier) {
        return (b << 2) | GRAYCODE[classifier(image, offset)];
      };
      return classifiers.reduce(classify, 0);
    };
    return function(image) {
      var img, k, length, offset, ref, results;
      length = measure(image).h - max + 1;
      img = integral(image);
      results = [];
      for (offset = k = 0, ref = length; 0 <= ref ? k < ref : k > ref; offset = 0 <= ref ? ++k : --k) {
        results.push(subfingerprint(img, offset));
      }
      return results;
    };
  };

  this.chromaprint.calculator = calculator;

}).call(this);
// Generated by CoffeeScript 1.12.7
(function() {
  var NUM_BANDS, chroma, freqToOctave, log2;

  if (this.chromaprint == null) {
    this.chromaprint = {};
  }

  NUM_BANDS = 12;

  log2 = Math.log(2);

  freqToOctave = function(freq, base) {
    if (base == null) {
      base = 440 / 16.0;
    }
    return Math.log(freq / base) / log2;
  };

  chroma = function(minFreq, maxFreq, frameSize, sampleRate, interpolate) {
    var features, freqToIndex, i, indexToFreq, indexToOctave, j, maxIndex, minIndex, notes, octave, ref, ref1;
    notes = [];
    features = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    freqToIndex = function(frq) {
      return Math.round(frameSize * frq / sampleRate);
    };
    indexToFreq = function(idx) {
      return (idx * sampleRate) / frameSize;
    };
    indexToOctave = function(i) {
      return freqToOctave(indexToFreq(i));
    };
    minIndex = Math.max(1, freqToIndex(minFreq));
    maxIndex = Math.min(frameSize / 2, freqToIndex(maxFreq));
    for (i = j = ref = minIndex, ref1 = maxIndex; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
      octave = indexToOctave(i);
      notes[i] = NUM_BANDS * (octave - Math.floor(octave));
    }
    return function(frame) {
      var a, e, energy, fraction, k, note, ref2, ref3, unit, unit2;
      energy = function(i) {
        var ref2;
        return (ref2 = frame[i]) != null ? ref2 : 0;
      };
      for (i = k = ref2 = minIndex, ref3 = maxIndex; ref2 <= ref3 ? k < ref3 : k > ref3; i = ref2 <= ref3 ? ++k : --k) {
        e = energy(i);
        note = notes[i];
        unit = Math.floor(note);
        fraction = note - unit;
        if (interpolate) {
          if (fraction < 0.5) {
            unit2 = (unit + NUM_BANDS - 1) % NUM_BANDS;
            a = 0.5 + fraction;
          } else if (fraction > 0.5) {
            unit2 = (unit + 1) % NUM_BANDS;
            a = 1.5 - fraction;
          } else {
            unit2 = unit;
            a = 1.0;
          }
          features[unit] += e * a;
          features[unit2] += e * (1 - a);
        } else {
          features[unit] += e;
        }
      }
      return features;
    };
  };

  this.chromaprint.chroma = chroma;

}).call(this);
// Generated by CoffeeScript 1.12.7
(function() {
  var compare_b64_fingerprint, ord;

  ord = function(string) {
    var code, hi, low, str;
    str = string + '';
    code = str.charCodeAt(0);
    if (code >= 0xD800 && code <= 0xDBFF) {
      hi = code;
      if (str.length === 1) {
        return code;
      }
      low = str.charCodeAt(1);
      return (hi - 0xD800) * 0x400 + low - 0xDC00 + 0x10000;
    }
    if (code >= 0xDC00 && code <= 0xDFFF) {
      return code;
    }
    return code;
  };

  compare_b64_fingerprint = function(a, b) {
    'returns inverse bit error rate in percent';
    var bit_a, bit_b, byte_a, byte_b, different_bits, i, longest, matching_bits, shortest, total_bits, x;
    a = b64decode(a);
    b = b64decode(b);
    matching_bits = 0;
    different_bits = 0;
    if (b.length !== a.length) {
      shortest = min(len(a), len(b));
      longest = max(len(a), len(b));
      a = a.slice(0, shortest);
      b = b.slice(0, shortest);
      different_bits = 8 * (longest - shortest);
    }
    i = 0;
    while (i < a.length) {
      byte_a = ord(a.slice(i, i + 1));
      byte_b = ord(b.slice(i, i + 1));
      x = 0;
      while (x < 8) {
        bit_a = byte_a >> x & 1;
        bit_b = byte_b >> x & 1;
        if (bit_a === bit_b) {
          matching_bits += 1;
        } else {
          different_bits += 1;
        }
        x++;
      }
      i++;
    }
    total_bits = different_bits + matching_bits;
    return float(matching_bits) / float(total_bits);
  };

}).call(this);
// Generated by CoffeeScript 1.12.7
(function() {
  var Promise, cli, fpcalc, fs, path, print, run;

  if (!((typeof require !== "undefined" && require !== null) && (typeof module !== "undefined" && module !== null))) {
    return;
  }

  fs = require('fs');

  cli = require('commander');

  path = require('path');

  Promise = require('q');

  cli.description("Print the audio fingerprint of one or more files.");

  cli.usage('[options] <file ...>');

  // cli.version(require('../package').version);

  cli.option('-l, --length SECS', 'seconds of audio to scan [120]', parseInt, 120);

  cli.option('-r, --raw', 'output the raw uncompressed fingerprint');

  cli.option('-a, --algo TEST', 'choose an algorithm (1-4) [2]', parseInt, 2);

  print = function(file, length, fingerprint) {
    console.log("FILE=" + file);
    console.log("DURATION=" + length);
    console.log("FINGERPRINT=" + fingerprint);
    return console.log("");
  };

  fpcalc = function(file, length, raw, algorithm, callback) {
    var audioBuffer, l, offset, position, read, readCallback;
    offset = 0;
    position = null;
    l = 2048;
    audioBuffer = new Buffer(l);
    readCallback = function(err, bytesRead, buffer) {
      if (err != null) {
        return callback(err);
      }
      console.log("Read " + bytesRead + " bytes => " + buffer);
      console.log("  audioBuffer is now: " + buffer);
      console.log("  ... I think I will stop now.");
      return callback(null, audioBuffer);
    };
    read = function(err, fd) {
      if (err != null) {
        return callback(err);
      }
      return fs.read(fd, audioBuffer, offset, l, position, callback);
    };
    return fs.exists(path.resolve(file), function(ok) {
      if (ok) {
        return fs.open(file, 'r', read);
      }
      return callback(Error(file + " - no such file "));
    });
  };

  run = function(args) {
    var algorithm, f, length, raw;
    if (args == null) {
      args = process.argv;
    }
    cli.parse(args);
    raw = !!cli.raw;
    length = cli.length || 120;
    algorithm = cli.algorithm || 2;
    if (!cli.args.length) {
      cli.help();
    }
    f = function(file, cb) {
      return fpcalc(file, length, raw, algorithm, cb);
    };
    return cli.args.reverse().reduce((function(p, n) {
      return function() {
        return f(n, p);
      };
    }), function() {})();
  };

  if (typeof module !== "undefined" && module !== null) {
    module.exports = run;
  }

}).call(this);
// Generated by CoffeeScript 1.12.7
(function() {
  var silenceRemover;

  if (this.chromaprint == null) {
    this.chromaprint = {};
  }

  silenceRemover = function(threshold, window) {
    var filter;
    if (window == null) {
      window = 55;
    }
    filter = function(window) {
      var finished;
      finished = false;
      return function(byte, index) {
        return finished || (finished = ((window += byte) / (index + 1)) > threshold);
      };
    };
    return function(input) {
      return input.filter(filter(window));
    };
  };

  this.chromaprint.silenceRemover = silenceRemover;

}).call(this);
